const { getOverseasDailyChart } = require('./koreaInvestment');
const cron = require('node-cron');

class SimpleRSService {
  constructor() {
    this.isCalculating = false;
    this.rsData = new Map(); // Ï¢ÖÎ™©Î≥Ñ RS Îç∞Ïù¥ÌÑ∞ Ï†ÄÏû•
    this.lastUpdate = null;
    this.setupScheduler();
  }

  /**
   * Ïä§ÏºÄÏ§ÑÎü¨ ÏÑ§Ï†ï (Îß§Ïùº Ïò§ÌõÑ 6ÏãúÏóê Í≥ÑÏÇ∞)
   */
  setupScheduler() {
    // Îß§Ïùº Ïò§ÌõÑ 6ÏãúÏóê RS Í≥ÑÏÇ∞ Ïã§Ìñâ (ÎØ∏Íµ≠ ÏãúÏû• ÎßàÍ∞ê ÌõÑ)
    cron.schedule('0 18 * * *', async () => {
      console.log('üìä RS Í≥ÑÏÇ∞ Ïä§ÏºÄÏ§ÑÎü¨ Ïã§Ìñâ');
      await this.calculateRS();
    });
  }

  /**
   * Ï£ºÏöî Ï¢ÖÎ™© Î¶¨Ïä§Ìä∏ (ÎÇòÏä§Îã•, Îâ¥Ïöï Ï£ºÏöî Ï¢ÖÎ™©Îì§)
   */
  getPopularStocks() {
    return [
      // ÎÇòÏä§Îã• Ï£ºÏöî Ï¢ÖÎ™©
      'AAPL', 'MSFT', 'GOOGL', 'AMZN', 'TSLA', 'META', 'NVDA', 'NFLX'
    //   'AMD', 'INTC', 'PYPL', 'ADBE', 'CSCO', 'PEP', 'AVGO', 'COST',
    //   'QCOM', 'TXN', 'INTU', 'ISRG', 'BKNG', 'GILD', 'MDLZ', 'REGN',
      
    //   // Îâ¥Ïöï Ï£ºÏöî Ï¢ÖÎ™©
    //   'JPM', 'JNJ', 'WMT', 'PG', 'UNH', 'HD', 'MA', 'BAC', 'DIS',
    //   'V', 'ADBE', 'CRM', 'NFLX', 'KO', 'MRK', 'PFE', 'ABT', 'TMO',
    //   'ACN', 'VZ', 'CMCSA', 'DHR', 'NKE', 'LLY', 'ABBV', 'CVX',
    ];
  }

  /**
   * RS Í≥ÑÏÇ∞ Î©îÏù∏ Ìï®Ïàò
   */
  async calculateRS() {
    if (this.isCalculating) {
      console.log('Ïù¥ÎØ∏ RS Í≥ÑÏÇ∞ ÏßÑÌñâ Ï§ë...');
      return;
    }

    this.isCalculating = true;
    console.log('üöÄ RS Í≥ÑÏÇ∞ ÏãúÏûë...');

    try {
      const stocks = this.getPopularStocks();
      const rsResults = [];

             // Í∞Å Ï¢ÖÎ™©Î≥ÑÎ°ú Îç∞Ïù¥ÌÑ∞ ÏàòÏßë Î∞è RS Í≥ÑÏÇ∞
       for (const symbol of stocks) {
         try {
           console.log(`üìà ${symbol} RS Í≥ÑÏÇ∞ Ï§ë...`);
           
           // ÏµúÍ∑º 30Ïùº Îç∞Ïù¥ÌÑ∞ Í∞ÄÏ†∏Ïò§Í∏∞
           const stockData = await this.getStockHistoryData(symbol);
           
           console.log(`${symbol} Îç∞Ïù¥ÌÑ∞ Í∏∏Ïù¥:`, stockData ? stockData.length : 'null');
           
           if (stockData && stockData.length >= 1) { // 1Í∞ú Îç∞Ïù¥ÌÑ∞Îßå ÏûàÏñ¥ÎèÑ ÏãúÎèÑ
             console.log(`${symbol} Ï≤´ Î≤àÏß∏ Îç∞Ïù¥ÌÑ∞:`, stockData[0]);
             console.log(`${symbol} ÎßàÏßÄÎßâ Îç∞Ïù¥ÌÑ∞:`, stockData[stockData.length - 1]);
             
             const rs = this.calculateStockRS(stockData);
             console.log(`${symbol} RS Í≤∞Í≥º:`, rs);
             
             if (rs !== null) {
               const rsData = {
                 symbol: symbol,
                 relativeStrength: rs.rsScore,
                 pricePerformance: rs.performance,
                 currentPrice: stockData[stockData.length - 1].close,
                 changePercent: rs.dailyChange,
                 volume: stockData[stockData.length - 1].volume,
                 lastUpdate: new Date().toISOString()
               };
               
               console.log(`${symbol} ÏµúÏ¢Ö RS Îç∞Ïù¥ÌÑ∞:`, rsData);
               rsResults.push(rsData);
             } else {
               console.log(`${symbol} RS Í≥ÑÏÇ∞ Í≤∞Í≥ºÍ∞Ä null`);
             }
           } else {
             console.log(`${symbol} Îç∞Ïù¥ÌÑ∞ Î∂ÄÏ°±: ${stockData ? stockData.length : 'null'}Í∞ú`);
           }
           
           // API Ìò∏Ï∂ú Í∞ÑÍ≤© (429 ÏóêÎü¨ Î∞©ÏßÄ)
           await this.delay(500); // Í∞ÑÍ≤©ÏùÑ ÎäòÎ†§ÏÑú ÏïàÏ†ïÏÑ± ÌôïÎ≥¥
           
         } catch (error) {
           console.error(`${symbol} RS Í≥ÑÏÇ∞ Ïã§Ìå®:`, error.message);
         }
       }

      // ÏãúÏû• ÌèâÍ∑† Í≥ÑÏÇ∞
      const marketAverage = this.calculateMarketAverage(rsResults);
      
      // ÏÉÅÎåÄ Í∞ïÎèÑ Ï°∞Ï†ï (ÏãúÏû• ÎåÄÎπÑ)
      rsResults.forEach(stock => {
        stock.relativeStrength = stock.relativeStrength - marketAverage;
      });

      // RS ÏàúÏúÑ Îß§Í∏∞Í∏∞
      rsResults.sort((a, b) => b.relativeStrength - a.relativeStrength);
      rsResults.forEach((stock, index) => {
        stock.rank = index + 1;
      });

      // Î©îÎ™®Î¶¨Ïóê Ï†ÄÏû•
      this.rsData.clear();
      rsResults.forEach(stock => {
        this.rsData.set(stock.symbol, stock);
      });

      this.lastUpdate = new Date().toISOString();
      console.log(`‚úÖ RS Í≥ÑÏÇ∞ ÏôÑÎ£å: ${rsResults.length}Í∞ú Ï¢ÖÎ™©`);
      console.log(`üèÜ ÏÉÅÏúÑ 5Í∞ú Ï¢ÖÎ™©:`, rsResults.slice(0, 5).map(s => `${s.symbol} (${s.relativeStrength.toFixed(2)})`));

    } catch (error) {
      console.error('‚ùå RS Í≥ÑÏÇ∞ Ïã§Ìå®:', error);
    } finally {
      this.isCalculating = false;
    }
  }

     /**
    * Ï¢ÖÎ™© ÌûàÏä§ÌÜ†Î¶¨ Îç∞Ïù¥ÌÑ∞ Í∞ÄÏ†∏Ïò§Í∏∞
    */
   async getStockHistoryData(symbol) {
     try {
            // ÏµúÍ∑º 45Ïùº Îç∞Ïù¥ÌÑ∞ Í∞ÄÏ†∏Ïò§Í∏∞ (20Ïùº ÏÑ±Í≥º Í≥ÑÏÇ∞ÏùÑ ÏúÑÌï¥)
     const endDate = new Date();
     const startDate = new Date(endDate.getTime() - 45 * 24 * 60 * 60 * 1000);
       
       const formatDate = (date) => {
         const year = date.getFullYear();
         const month = String(date.getMonth() + 1).padStart(2, '0');
         const day = String(date.getDate()).padStart(2, '0');
         return `${year}${month}${day}`;
       };

       console.log(`${symbol} API Ìò∏Ï∂ú: ${formatDate(startDate)} ~ ${formatDate(endDate)}`);

       const result = await getOverseasDailyChart(
         symbol,
         'D',
         formatDate(startDate),
         formatDate(endDate)
       );

              console.log(`${symbol} API ÏùëÎãµ:`, {
         totalCount: result.totalCount,
         dataLength: result.data ? result.data.length : 'null',
         firstItem: result.data && result.data.length > 0 ? result.data[0] : 'no data',
         basicData: result.basicData && result.basicData.length > 0 ? result.basicData[0] : 'no basic data'
       });

       // Îç∞Ïù¥ÌÑ∞Í∞Ä ÏóÜÏúºÎ©¥ basicDataÎèÑ ÌôïÏù∏
       let chartData = result.data || [];
       
       if (chartData.length === 0 && result.basicData && result.basicData.length > 0) {
         console.log(`${symbol} Ï∞®Ìä∏ Îç∞Ïù¥ÌÑ∞Í∞Ä ÏóÜÏñ¥ÏÑú basicData ÏÇ¨Ïö©`);
         const basic = result.basicData[0];
         chartData = [{
           date: new Date().toISOString().slice(0, 10).replace(/-/g, ''),
           open: basic.open,
           high: basic.high,
           low: basic.low,
           close: basic.close,
           volume: 0
         }];
       }

       if (chartData.length === 0) {
         console.log(`${symbol} Î™®Îì† Îç∞Ïù¥ÌÑ∞Í∞Ä ÎπÑÏñ¥ÏûàÏùå`);
         return null;
       }

       // ÎÇ†Ïßú Ï†ïÎ†¨ (ÌïúÍµ≠Ìà¨ÏûêÏ¶ùÍ∂å APIÎäî YYYYMMDD ÌòïÏãù)
       const sortedData = chartData.sort((a, b) => {
         const dateA = a.date ? a.date.toString() : '';
         const dateB = b.date ? b.date.toString() : '';
         return dateA.localeCompare(dateB);
       });
       
       console.log(`${symbol} Ï†ïÎ†¨Îêú Îç∞Ïù¥ÌÑ∞ Í∏∏Ïù¥: ${sortedData.length}`);
       
       // Îç∞Ïù¥ÌÑ∞ Ïú†Ìö®ÏÑ± Í≤ÄÏÇ¨ Î∞è Î≥ÄÌôò
       const validData = sortedData.map(item => {
         const close = parseFloat(item.close);
         const open = parseFloat(item.open || item.close);
         const high = parseFloat(item.high || item.close);
         const low = parseFloat(item.low || item.close);
         const volume = parseInt(item.volume || 0);
         
         return {
           date: item.date,
           open: isNaN(open) ? close : open,
           high: isNaN(high) ? close : high,
           low: isNaN(low) ? close : low,
           close: close,
           volume: isNaN(volume) ? 0 : volume
         };
       }).filter(item => !isNaN(item.close) && item.close > 0);
       
       console.log(`${symbol} Ïú†Ìö®Ìïú Îç∞Ïù¥ÌÑ∞ Í∏∏Ïù¥: ${validData.length}`);
       console.log(`${symbol} Ï≤´ Î≤àÏß∏ Ïú†Ìö® Îç∞Ïù¥ÌÑ∞:`, validData[0]);
       console.log(`${symbol} ÎßàÏßÄÎßâ Ïú†Ìö® Îç∞Ïù¥ÌÑ∞:`, validData[validData.length - 1]);
       
       return validData;

     } catch (error) {
       console.error(`${symbol} ÌûàÏä§ÌÜ†Î¶¨ Îç∞Ïù¥ÌÑ∞ Í∞ÄÏ†∏Ïò§Í∏∞ Ïã§Ìå®:`, error.message);
       return null;
     }
   }

     /**
    * Í∞úÎ≥Ñ Ï¢ÖÎ™© RS Í≥ÑÏÇ∞
    */
   calculateStockRS(stockData) {
     try {
       console.log(`RS Í≥ÑÏÇ∞ ÏãúÏûë - Îç∞Ïù¥ÌÑ∞ Í∏∏Ïù¥: ${stockData.length}`);
       
       // Ï¢ÖÍ∞Ä Îç∞Ïù¥ÌÑ∞Î•º Ïà´ÏûêÎ°ú Î≥ÄÌôò
       const prices = stockData.map(d => {
         const price = parseFloat(d.close);
         if (isNaN(price) || price <= 0) {
           console.log(`ÏûòÎ™ªÎêú Í∞ÄÍ≤© Îç∞Ïù¥ÌÑ∞:`, d);
           return null;
         }
         return price;
       }).filter(price => price !== null);
       
       console.log(`Í∞ÄÍ≤© Îç∞Ïù¥ÌÑ∞ Ï≤´ 5Í∞ú:`, prices.slice(0, 5));
       console.log(`Í∞ÄÍ≤© Îç∞Ïù¥ÌÑ∞ ÎßàÏßÄÎßâ 5Í∞ú:`, prices.slice(-5));
       
       if (prices.length < 2) {
         console.log(`Ïú†Ìö®Ìïú Í∞ÄÍ≤© Îç∞Ïù¥ÌÑ∞ Î∂ÄÏ°±: ${prices.length}Í∞ú`);
         return null;
       }
       
       const latestPrice = prices[prices.length - 1];
       const previousPrice = prices[prices.length - 2];
       
       console.log(`ÏµúÏã† Í∞ÄÍ≤©: ${latestPrice}, Ï†ÑÏùº Í∞ÄÍ≤©: ${previousPrice}`);
       
       // Ïó¨Îü¨ Í∏∞Í∞Ñ ÏÑ±Í≥º Í≥ÑÏÇ∞ (Îç∞Ïù¥ÌÑ∞ ÏñëÏóê Îî∞Îùº Ï°∞Ï†ï)
       const availablePeriods = [1, 3, 5, 10, 20].filter(p => p < prices.length);
       const performances = {};
       let totalRS = 0;
       let validPeriods = 0;

       if (availablePeriods.length === 0 && prices.length >= 2) {
         // ÏµúÏÜå 2Í∞ú Îç∞Ïù¥ÌÑ∞Í∞Ä ÏûàÏúºÎ©¥ 1Ïùº ÏÑ±Í≥ºÎùºÎèÑ Í≥ÑÏÇ∞
         availablePeriods.push(1);
       }

       availablePeriods.forEach(period => {
         if (prices.length > period) {
           const oldPrice = prices[prices.length - period - 1];
           const performance = ((latestPrice - oldPrice) / oldPrice) * 100;
           performances[`${period}d`] = performance;
           totalRS += performance;
           validPeriods++;
           
           console.log(`${period}Ïùº ÏÑ±Í≥º: ${oldPrice} -> ${latestPrice} = ${performance.toFixed(2)}%`);
         } else {
           console.log(`${period}Ïùº ÏÑ±Í≥º Í≥ÑÏÇ∞ Î∂àÍ∞Ä - Îç∞Ïù¥ÌÑ∞ Î∂ÄÏ°± (${prices.length} <= ${period})`);
         }
       });

       // Îç∞Ïù¥ÌÑ∞Í∞Ä 1Í∞úÎøêÏù¥Î©¥ 0%Î°ú Ï≤òÎ¶¨
       if (prices.length === 1) {
         performances['1d'] = 0;
         totalRS = 0;
         validPeriods = 1;
         console.log('Îç∞Ïù¥ÌÑ∞Í∞Ä 1Í∞úÎøêÏù¥ÎØÄÎ°ú ÏÑ±Í≥ºÎ•º 0%Î°ú ÏÑ§Ï†ï');
       }

       const rsScore = validPeriods > 0 ? totalRS / validPeriods : 0;
       const dailyChange = previousPrice ? ((latestPrice - previousPrice) / previousPrice) * 100 : 0;

       const result = {
         rsScore: rsScore,
         performance: performances,
         dailyChange: dailyChange
       };
       
       console.log(`ÏµúÏ¢Ö RS Í≤∞Í≥º:`, result);
       
       return result;

     } catch (error) {
       console.error('RS Í≥ÑÏÇ∞ Ïò§Î•ò:', error);
       return null;
     }
   }

  /**
   * ÏãúÏû• ÌèâÍ∑† Í≥ÑÏÇ∞
   */
  calculateMarketAverage(rsResults) {
    if (rsResults.length === 0) return 0;
    
    const totalRS = rsResults.reduce((sum, stock) => sum + stock.relativeStrength, 0);
    return totalRS / rsResults.length;
  }

  /**
   * ÏßÄÏó∞ Ìï®Ïàò (API Ìò∏Ï∂ú Í∞ÑÍ≤© Ï°∞Ï†à)
   */
  delay(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  }

  /**
   * RS Î¶¨Îçî Ï°∞Ìöå
   */
  getTopRS(limit = 50) {
    if (this.rsData.size === 0) {
      return {
        leaders: [],
        message: 'RS Îç∞Ïù¥ÌÑ∞Í∞Ä ÏóÜÏäµÎãàÎã§. Ïû†Ïãú ÌõÑ Îã§Ïãú ÏãúÎèÑÌïòÏÑ∏Ïöî.',
        lastUpdate: this.lastUpdate
      };
    }

    const leaders = Array.from(this.rsData.values())
      .sort((a, b) => b.relativeStrength - a.relativeStrength)
      .slice(0, limit);

    return {
      leaders: leaders,
      totalCount: this.rsData.size,
      lastUpdate: this.lastUpdate
    };
  }

  /**
   * Í≥†Í∏â ÌïÑÌÑ∞ÎßÅ RS Î¶¨Îçî Ï°∞Ìöå
   */
  getAdvancedRS(criteria = {}) {
    const {
      minRS = 0,
      minPrice = 0,
      maxPrice = 10000,
      minDailyGain = -100,
      limit = 30
    } = criteria;

    if (this.rsData.size === 0) {
      return {
        leaders: [],
        message: 'RS Îç∞Ïù¥ÌÑ∞Í∞Ä ÏóÜÏäµÎãàÎã§. Ïû†Ïãú ÌõÑ Îã§Ïãú ÏãúÎèÑÌïòÏÑ∏Ïöî.',
        lastUpdate: this.lastUpdate
      };
    }

    const leaders = Array.from(this.rsData.values())
      .filter(stock => 
        stock.relativeStrength >= minRS &&
        stock.currentPrice >= minPrice &&
        stock.currentPrice <= maxPrice &&
        stock.changePercent >= minDailyGain
      )
      .sort((a, b) => b.relativeStrength - a.relativeStrength)
      .slice(0, limit);

    return {
      leaders: leaders,
      criteria: criteria,
      totalCount: leaders.length,
      lastUpdate: this.lastUpdate
    };
  }

  /**
   * RS ÌÜµÍ≥Ñ Ï°∞Ìöå
   */
  getStats() {
    if (this.rsData.size === 0) {
      return {
        totalStocks: 0,
        avgRS: 0,
        maxRS: 0,
        minRS: 0,
        positiveRS: 0,
        negativeRS: 0,
        positivePercentage: 0,
        lastUpdate: this.lastUpdate
      };
    }

    const rsValues = Array.from(this.rsData.values()).map(s => s.relativeStrength);
    const positiveCount = rsValues.filter(rs => rs > 0).length;
    const negativeCount = rsValues.filter(rs => rs < 0).length;

    return {
      totalStocks: this.rsData.size,
      avgRS: Math.round((rsValues.reduce((sum, rs) => sum + rs, 0) / rsValues.length) * 100) / 100,
      maxRS: Math.round(Math.max(...rsValues) * 100) / 100,
      minRS: Math.round(Math.min(...rsValues) * 100) / 100,
      positiveRS: positiveCount,
      negativeRS: negativeCount,
      positivePercentage: Math.round((positiveCount / rsValues.length) * 100),
      lastUpdate: this.lastUpdate
    };
  }

  /**
   * ÏàòÎèô RS Í≥ÑÏÇ∞ Ìä∏Î¶¨Í±∞
   */
  async triggerCalculation() {
    console.log('üîÑ ÏàòÎèô RS Í≥ÑÏÇ∞ Ìä∏Î¶¨Í±∞');
    await this.calculateRS();
  }

     /**
    * ÏÑúÎπÑÏä§ ÏãúÏûë Ïãú Ï¥àÍ∏∞ Îç∞Ïù¥ÌÑ∞ Î°úÎìú
    */
   async initialize() {
     console.log('üìä SimpleRS ÏÑúÎπÑÏä§ Ï¥àÍ∏∞Ìôî...');
     
     // 3Ï¥à ÌõÑ Ï≤´ RS Í≥ÑÏÇ∞ Ïã§Ìñâ (Îπ†Î•∏ ÌÖåÏä§Ìä∏Î•º ÏúÑÌï¥)
     setTimeout(() => {
       console.log('‚è∞ 3Ï¥à ÌõÑ RS Í≥ÑÏÇ∞ ÏãúÏûë...');
       this.calculateRS();
     }, 3000);
   }
}

// Ïã±Í∏ÄÌÜ§ Ïù∏Ïä§ÌÑ¥Ïä§
const simpleRSService = new SimpleRSService();

module.exports = simpleRSService; 